<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="GET_STOREDPROCEDURE_PARAMETERS" xml:space="preserve">
    <value>SELECT 
	prm.PARAMETER_NAME,
	prm.DATA_TYPE,
	prm.CHARACTER_MAXIMUM_LENGTH,
	prm.PARAMETER_MODE,
	prm.ORDINAL_POSITION
FROM INFORMATION_SCHEMA.PARAMETERS prm
WHERE
	prm.SPECIFIC_SCHEMA = @SPECIFIC_SCHEMA
AND prm.SPECIFIC_NAME = @SPECIFIC_NAME

ORDER BY 
	prm.ORDINAL_POSITION</value>
  </data>
  <data name="GET_STORED_PROCEDURES" xml:space="preserve">
    <value>SELECT 
	sproc.SPECIFIC_SCHEMA,
	sproc.SPECIFIC_NAME
FROM INFORMATION_SCHEMA.ROUTINES sproc
WHERE sproc.ROUTINE_TYPE = 'PROCEDURE'</value>
  </data>
  <data name="GET_TABLES" xml:space="preserve">
    <value>SELECT 
	TABLE_SCHEMA, 
	TABLE_NAME
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE = 'BASE TABLE'
ORDER BY TABLE_SCHEMA, TABLE_NAME</value>
  </data>
  <data name="GET_TABLE_COLUMNS" xml:space="preserve">
    <value>SELECT 
	col.COLUMN_NAME,
	col.ORDINAL_POSITION,
	col.IS_NULLABLE,
	col.DATA_TYPE,
	col.CHARACTER_MAXIMUM_LENGTH,
	kcu.CONSTRAINT_NAME,
	tcnt.CONSTRAINT_TYPE,
	CASE tcnt.CONSTRAINT_TYPE
		WHEN 'PRIMARY KEY' THEN 'YES'
		ELSE 'NO'
	END AS IS_PRIMARY_KEY,
	CASE COLUMNPROPERTY(OBJECT_ID(col.TABLE_NAME), col.COLUMN_NAME,'IsIdentity')
		WHEN 1 THEN 'YES'
		ELSE 'NO'
	END AS IS_IDENTITY
FROM INFORMATION_SCHEMA.COLUMNS col
LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
	ON 
		kcu.TABLE_SCHEMA = col.TABLE_SCHEMA
		AND kcu.TABLE_NAME = col.TABLE_NAME
		AND kcu.COLUMN_NAME = col.COLUMN_NAME
LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tcnt
	ON 
		kcu.TABLE_SCHEMA = tcnt.TABLE_SCHEMA
		AND kcu.TABLE_NAME = tcnt.TABLE_NAME	
		AND tcnt.CONSTRAINT_TYPE = 'PRIMARY KEY'
WHERE 
		col.TABLE_SCHEMA = @TABLE_SCHEMA
		AND col.TABLE_NAME = @TABLE_NAME		
ORDER BY ORDINAL_POSITION</value>
  </data>
  <data name="GET_TABLE_KEYS" xml:space="preserve">
    <value>--DECLARE @SCHEMA_NAME VARCHAR(50)
--DECLARE @TABLE_NAME VARCHAR(100)

--SET @SCHEMA_NAME = 'dbo'
--SET @TABLE_NAME = 'Customers'

DECLARE @TMP_KEYS TABLE (
	ID INT IDENTITY (1,1),
	KEY_OBJECT_ID VARCHAR(100),
	INDEX_ID VARCHAR(100),
	KEY_NAME VARCHAR(250)
)

INSERT INTO @TMP_KEYS (KEY_OBJECT_ID, INDEX_ID, KEY_NAME)
SELECT
	idx.[object_id],
	idx.index_id,
	idx.name
FROM sys.indexes idx	
JOIN sys.tables tabl on idx.object_id = tabl.object_id
JOIN sys.schemas schem ON tabl.schema_id = schem.schema_id
WHERE tabl.name = @TABLE_NAME
AND schem.name = @SCHEMA_NAME

select 
	idx.name AS 'KEY_NAME', 	
	CASE idx.type
		WHEN 1 then 'PRIMARY_KEY'
		WHEN 2 then 'INDEX'
	END AS KEY_TYPE	
from sys.indexes idx	
JOIN sys.tables tabl on idx.object_id = tabl.object_id
JOIN sys.schemas schem ON tabl.schema_id = schem.schema_id
WHERE tabl.name = @TABLE_NAME
AND schem.name = @SCHEMA_NAME

SELECT 
	tmp.KEY_NAME, 
	col.name AS 'COLUMN_NAME',  
	CASE idc.is_descending_key
		WHEN 1 THEN 'DESC'
		ELSE 'ASC'
	END AS 'SORT_DIRECTION',
	idc.KEY_ORDINAL	
FROM sys.index_columns idc
JOIN @TMP_KEYS tmp ON tmp.KEY_OBJECT_ID = idc.object_id AND tmp.index_id = idc.index_id
JOIN sys.columns col ON idc.object_id = col.object_id AND col.column_id = idc.column_id
ORDER BY tmp.KEY_NAME, idc.KEY_ORDINAL</value>
  </data>
  <data name="GET_VIEWS" xml:space="preserve">
    <value>SELECT 
	TABLE_SCHEMA, 
	TABLE_NAME 
FROM INFORMATION_SCHEMA.VIEWS
ORDER BY TABLE_SCHEMA, TABLE_NAME</value>
  </data>
</root>